- ### 1. 输入网址后到网页显示，发生了什么？

  

  一、网络通信

  互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。

  分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走。

  1. 在浏览器中输入url

  用户输入url，例如http://www.baidu.com。其中http为协议，www.baidu.com为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。

  1. 应用层DNS解析域名

  客户端先检查本地域名服务器是否有对应的IP地址，若找到则返回响应的IP地址。若没则由本地域名服务器去向根域名服务器请求该域名的ip，根域名服务器不会直接告诉你ip，而是会指明让你去哪个服务器上可以找到该域名ip，最后获得该域名的ip，将其保存到自己的缓存表中。

  1. 应用层客户端发送HTTP请求

  这时候会生成http请求报文，HTTP请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET / POST）、目标url、遵循的协议（http / https / ftp…），返回的信息是否需要缓存，以及客户端是否发送cookie等。

  1. 传输层TCP传输报文

  位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。

  “三次握手”的过程是，发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。

  1. 网络层IP协议查询MAC地址

  IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。

  1. 数据到达数据链路层

  在找到对方的MAC地址后，在ip报文首部加上mac的头部就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束

  1. 服务器接收数据

  接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议讲分段的数据包重新组成原来的HTTP请求报文。

  1. 服务器响应请求

  服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后将http请求的url做相应的改变再重新发送。404 not found 表示客户端请求的资源找不到。

  1.  服务器返回相应文件
     请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。

  

  ### 2．Tcp三次握手

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-1627710472983.png)

  Tcp是面向连接的，使用前需要先通过三次握手建立连接。

  a.	首先，客户端和服务端都处理closed状态，服务端会一直监听某个端口，处理LISTEN状态

  b.	客户端随机初始化序列号x，将此序号放在tcp首部的序列号字段中，同时把SYN标志位置1，表示这是SYN报文。接着把第一个SYN报文发送到服务端，表示向服务端发起连接，该报文不包含数据，之后客户端处于SYN-SENT状态

  c.	服务端接受到客户端的SYN报文后，首先服务端也初始化自己的序号y,将y写入tcp首部的序号字段中，其次把tcp的首部应答号字段填入x+1，接着把SYN和ACK标志位都置为1。最后把报文发给客户端，之后服务端处于SYN-RECD状态。

  d.	客户端收到报文后，还要再向服务端回应最后一个应答报文，首先将tcp首部报文ACK置位为1，其次确认应答号字段填入y+1,最后把该报文发给服务端，这次的报文可以携带客户端的数据，之后进入established状态

  e.	服务端收到后也进入established状态

  

  ### 为什么需要三次握手？

  a.	阻止重复历史连接的初始化（最重要的原因）：假设由于网络阻塞导致，客户端发送多次SYN建立连接，当出现旧的SYN报文比新的更先到达服务端，此时服务端会返回一个SYN+ACK，客户端接收到发现这时一个历史连接，客户端会发送RST报文给服务端中断这次连接。如果两次的话无法到达效果

  b.	同步双方初始化序列号

  c.	避免资源浪费：如果客户端发送多个SYN报文，没有第三次握手，客户端不确定服务端什么时候收到了自己发起建立的连接， 那么服务器在收到请求后就会建立多个冗余的无效连接，造成不必要的资源浪费。

  

  TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。

  不使用「两次握手」和「四次握手」的原因：

  「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；

  「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

  

  ### TCP四次挥手：

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-1627710473026.png)

  a.	客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。

  b.	服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状 态。

  c.	客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。

  d.	等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。

  e.	客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态 服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭。

  f.	客户端在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭。

  每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手

  为什么 TIME_WAIT 等待的时间是 2MSL(报文最大生存时间)？

  MSL是任何报文在网络上存在的最长时间， 超过这个时间报文将被丢弃

  网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待2倍的时间。

  

  如何解决 TIME_WAIT 过多的问题？

  打开系统的TIMEWAIT重用和快速回收

  

  - FIN_WAIT_2：

  - 半关闭状态。
  - 发送断开请求一方还有接收数据能力，但已经没有发送数据能力。

  - CLOSE_WAIT状态：

  - 被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。
  - 被动关闭连接一方如果还有剩余数据要发送就会进入CLOSED_WAIT状态。

  - TIME_WAIT状态：

  - 又叫2MSL等待状态。
  - 如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。

  - 在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。

  

  

  

  ### 如何保证TCP的可靠传输？

  TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-1627710473017.png)

  

  **重点介绍 TCP 的重传机制、滑动窗口、流量控制、拥塞控制**

  

  #### 重传机制

  tcp实现可靠传输的方式之一，是通过序列号与确认应答。

  在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。

  针对数据包丢失的情况，会用重传机制解决。 接下来说说常见的重传机制： 

  - 超时重传 
  - 快速重传 

  - SACK 
  - D-SACK

  **超时重传**

  重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的ACK确认应答报文，就会重发该数据。TCP 会在以下两种情况发生超时重传： 数据包丢失、确认应答丢失

  超时重传时间表示为RTO，RTO应该略大于RTT（往返时延：数据从网络一端传到另一端所需的时间）

  **快速重传**

  快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文 段。

  快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的 时候，是重传之前的一个，还是重传所有的问题。这个都有可能，所以就有了**SAC****K**方法

  **SACK（选择性确认）**

  要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。

  **D-SACK** (Duplicate SACK)

  Duplicate SACK 又称  ，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。 下面举例两个栗子，来说明 D-SACK 的作用。

  

  #### 滑动窗口

  TCP 每发送一个数据，都要进行一次确认应答。这样往返时间越长，通信的效率就越低。 为解决这个问题，TCP 引入了窗口这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的 效率。

  窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲 区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

  采用累计确认或者累计应答，当收到了ACK700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。

  **窗口大小由哪一方决定？**

  TCP 头里有一个字段叫 Window ，也就是窗口大小。 这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的 处理能力来发送数据，而不会导致接收端处理不过来。 所以，通常窗口的大小是由接收方的窗口大小来决定的。 发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

  ### 

  #### 流量控制

  TCP 提供一种机制可以让接收方指明希望从发送方接收的数据大小（窗口大小），这就是所谓的流量控制。

  双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来，这时候接收方只能把处理不过来的数据存在缓存区里。如果缓存区满了发送方还在发送数据，接收方只能把收到的数据包丢掉，大量的丢包会极大着浪费网络资源，因此，需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。

  **窗口关闭**

  如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。

  **窗口关闭潜在的危险：**接收方向发送方通告窗口大小时，是通过 ACK 报文来通告的。 那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这 种相互等待的过程，会造成了死锁的现象。

  **如何解决：**TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给 出自己现在的接收窗口大小。

  **糊涂窗口综合症**

  糊涂窗口综合症的现象是可以发生在发送方和接收方： 接收方可以通告一个小的窗口 而发送方可以发送小数据 

  于是，要解决糊涂窗口综合症，就解决上面两个问题就可以了 让接收方不通告小窗口给发送方 让发送方避免发送小数据

  **解决方法：**

  接收方设置一个阈值min（缓存空间的1/2），小于此值，都会向发送方通告窗口为0

  发送放同时满足： 要等到窗口或数据大小大于缓存空间并且 收到之前发送数据的 ack 回包

  ### 

  #### 拥塞控制

  流量控制是接受方的处理速度慢，想要发送方减慢发送速度

  控制的目的就是避免发送方的数据填满整个网络，造成网络堵塞，而接受方的接受窗口可能还很大

  **拥塞窗口** cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。

  - 只要网络中没有出现拥塞， cwnd 就会增大； 
  - 但网络中出现了拥塞， cwnd 就减少；

  其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络 出现了拥塞。

  拥塞控制主要是四个算法： 

  - 慢启动 
  - 拥塞避免 

  - 拥塞发生 
  - 快速恢复

  **慢启动**

  TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据 包的数量，慢启动的算法规则：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。

  慢启动门限 ssthresh （slow start threshold）状态变量。

  - 当 cwnd < ssthresh 时，使用慢启动算法。
  - 当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」。

  **拥塞避免算法**

  当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法

  

  **拥塞发生** 

  当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种： 超时重传 快速重传

  发生超时重传的拥塞发生算法 

  **当发生了「超时重传」，则就会使用拥塞发生算法**。 这个时候，ssthresh 和 cwnd 的值会发生变化： 

  ssthresh 设为 cwnd/2 ，cwnd 重置为 1

  接着，就重新开始慢启动，慢启动是会突然减少数据流的。

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-1627710473083.png)

  **发生快速重传的拥塞发生算法**

  TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下： cwnd = cwnd/2 ，也就是设置为原来的一半; ssthresh = cwnd ; 进入快速恢复算法

  

  **快速恢复**

  快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也 不那么糟糕。 正如前面所说，进入快速恢复之前， cwnd 和 ssthresh 已被更新了： 

  - cwnd = cwnd/2 ，也就是设置为原来的一半;
  - ssthresh = cwnd ;

  然后，进入快速恢复算法如下： 

  - 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）； 
  - 重传丢失的数据包； 

  - 如果再收到重复的 ACK，那么 cwnd 增加 1； 
  - 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新 的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的 状态了，也即再次进入拥塞避免状态；

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image.png)

  

  

  

  

  ### 广播域和冲突域

  冲突域（物理分段）：

  连接在同一导线上的所有工作站的集合，或者说是同一物理网段上所有节点的集合或以太网上竞争同一带宽的节点集合。这个域代表了冲突在其中发生并传播的区域，这个区域可以被认为是共享段。在OSI模型中，冲突域被看作是第一层的概念，连接同一冲突域的设备有Hub简单复制信号的设备。而第二层设备（网桥，交换机）第三层设备（路由器）都可以隔离冲突域的。

  2、广播域：

  接收同样广播消息的节点的集合。如：在该集合中的任何一个节点传输一个广播帧，则所有其他能收到这个帧的节点都被认为是该广播帧的一部分。由于许多设备都极易产生广播，所以如果不维护，就会消耗大量的带宽，降低网络的效率。由于广播域被认为是OSI中的第二层概念，所以像Hub，交换机等第一，第二层设备连接的节点被认为都是在同一个广播域。而路由器，第三层交换机则可以隔离广播域。
  
  ### socket编程函数
  
  #### 服务端
  
  1. 创建套接字对象： 
  
  ```
  _domain 套接字使用的协议族信息
  _type 套接字的传输类型
  __protocol 通信协议
  int socket(int __domain, int __type, int __protocol) __THROW;
  ```
  
  2. 向套接字分配网络地址 
  
  ```
  fd:socket描述字，也就是socket引用
  myaddr:要绑定给sockfd的协议地址
  len:地址的长度
  int bind (int fd, const struct sockaddr* myaddr, socklen_t len)  __THROW;
  ```
  
  3. 进入等待连接请求状态
  
  ```
  __fd，分配所需的信息后的套接字
  __n  允许连接的个数
  extern int listen (int __fd, int __n) __THROW;
  ```
  
  4. 受理客户端的连接请求
  
  ```
  函数成功执行时返回socket文件描述符，失败时返回-1。
  __fd，要注意的是这个套接字文件描述符与前面几步的套接字文件描述符不同。
  addr   保存发起连接的客户端的地址信息。
  addr_len 保存该结构体的长度。
  extern int accept (int __fd, struct sockaddr *addr, socklen_t *addr_len);
  ```
  
  5. send/write发送信息
  
  ```
  linux下的发送函数为：
  ssize_t write (int __fd, const void *__buf, size_t __n) ;
  而在windows下的发送函数为：
  ssize_t send (int sockfd, const void *buf, size_t nbytes, int flag) ;
  第四个参数是传输数据时可指定的信息，一般设置为0。
  ```
  
  6. recv/read接受信息
  
  ```
  linux下的接收函数为
  ssize_t read (int __fd, void *__buf, size_t __nbytes);
  而在windows下的接收函数为
  ssize_t recv(int sockfd, void *buf, size_t nbytes, int flag) ;
  ```
  
  7. 关闭连接
  
  ```
  int close (int __fd);
  退出连接，此时要注意的是：调用close()函数即表示向对方发送了EOF结束标志信息。
  ```
  
  
  
  #### 客户端
  
  服务端的socket套接字在绑定自身的IP即 及端口号后这些信息后，就开始监听端口等待客户端的连接请求，此时客户端在创建套接字后就可以按照如下步骤与server端通信，创建套接字的过程不再重复了。
  
  \1. 请求连接
  
  ```
  int connect (int socket, struct sockaddr* servaddr, socklen_t addrlen);
  ```
  
  几个参数的意义和前面的accept函数意义一样。要注意的是服务器端收到连接请求的时候并不是马上调用accept()函数，而是把它放入到请求信息的等待队列中。
  
  **套接字的多种可选项**
  
  可以通过如下函数对套接字可选项的参数进行获取以及设置。
  
  ```
  extern int getsockopt (int sock, int __level, int __optname,
  		       void *__optval, socklen_t *optlen) __THROW;
  
  extern int setsockopt (int sock, int __level, int __optname,
  		       const void *__optval, socklen_t __optlen) __THROW;
  ```
  
  1. 设置可选项的IO缓冲区大小
  
  参考案例如下：
  
  ```
  int status, snd_buf;
  socklen_t len = sizeof(snd_buf);
  status = getsockopt(serv_socket, SOL_SOCKET, SO_SNDBUF, (void*)&snd_buf, &len);
  cout << "发送缓冲区大小: " << snd_buf <<endl;
  ```
  
  虽然可以获得的接收/发送缓冲区的大小，但是通过设置接收/发送缓冲区大小时，得到的结果会与我们期望的不一样，因为对缓冲区大小的设置是一件很谨慎的事，其自身会根据设置的值进行一定的优化。
  
  1. 是否启用地址再分配与Time-wait时间等待
  
  关于地址再分配问题会发生在这种情况下，首先看两种情况，假设客户端和服务器正在通讯。
  
  ① 在客户端的终端按`Crtl + c`或者其他方式断开与服务器的连接，此时客户端发送FIN消息，经过四次握手断开连接，操作系统关闭套接字，相当于`close()`的过程。然后在次启动客户端，顺利启动。
  
  ② 在服务端的终端按`Crtl + c`或者其他方式断开与客户端的连接，像①中一样，再次启动服务端，此时出现`bind() error`错误。
  
  服务器端出现这种情况的原因是调用套接字分配网络地址函数`bind()`的时候之前使用建立连接的同一端口号还没有来得及停用（大约要过两三分钟才处于可用状态），而客户端申请连接的端口是任意指定，程序运行时会动态分配端口号。
  
  服务器端端口没有被释放到被释放的时间状态称为Time-wait状态，这个状态的出现可以借助TCP断开连接的四次握手协议来分析，如下图：![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/1047362-20191127093057632-312140859.jpg)
  
  当client端发送`ACK=1 ack=k+1`这个消息给服务端就立即消除套接字，若此时该消息中途传输被遗失，则这个时候server端就永远无法收到client的`ACK`消息了。