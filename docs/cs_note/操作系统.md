+ 进程&线程

  + 进程

    + 进程的通信方式：管道、系统IPC、套接字

      + 管道pipe
        + 半双工通信方式，数据单向流动
        + 只能在具有亲缘关系(父子进程关系)进程间使用
        + 实质是一个内核缓冲区
        + 父进程创建管道，并在管道中写入数据，子进程从管道读数据
      + 命名管道FIFO
        + 有名管道也是半双工通信方式
        + 允许无亲缘关系进程见的通信
        + 命名管道的名字对应于一个磁盘索引节点

      + 消息队列MQ
        + 由消息的链表，存放在内核中并由消息队列标识符标识
        + 优点：克服了信号传递信息少，管道只能承载无格式字节流，缓冲区大小受限等缺点。
      + 共享内存SharedMemory
        + 映射一段能被其他进程所访问的内存，是最快的IPC方式
        + 通常与信号量等通信机制搭配，来实现进程间的同步和通信。
      + 信号量Semaphore
        + 采用计数器的形式，可以用来控制多个进程对共享资源的访问。
        + 操作系统实现是关中断的方式。
      + 套接字Socket
        + 可在不同机器上通信
      + 信号Sinal
        + 用于通知接收进程某个事件的发生

    + 进程的同步方式

      + 信号量
      + 管道
      + 消息队列

  + 线程

    + 线程的通信方式
      + 临界区
      + 互斥量
      + 信号量
      + 条件变量
      + 读写锁
    + 线程的同步方式
      + 互斥锁
      + 信号量
      + 条件变量
      + 读写锁
+ 动态分区分配算法
  + 首次适应算法：每次都从低地址开始查找，找到第一个满足大小的空闲分区
  + 最佳适应算法：优先使用更小的空闲区
    + 每次都使用最小的分区分配，会产生更小的内存，即很多外部碎片
  + 最坏适应算法：优先使用最大的连续空间区
    + 导致较大的空闲区很快用完，之后如果有大进程达到，则无内存可用
  + 邻近适应算法：在首次适应的基础上，设置一个循环链接，防止每次都从头开始查找，而这样就可以在上次查找的位置后查找可用位置
+ 虚拟技术
  + 时分复用：多个进程能在同一个处理器上并发执行使用了时分复用技术
  + 空分复用：虚拟内存使用了空分复用技术
+ 几种典型的锁
  + 读写锁
    + 多个读者可以同时读
    + 写者必须互斥，只允许一个写者写，读者写者不能同时进行
    + 写者优先于读者
  + 互斥锁
    + 一次只能一个线程拥有互斥锁，其他线程等待
    + 互斥锁在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时唤醒
    + 操作系统负责线程调度，为了实现锁的状态改变唤醒阻塞的线程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。
  + 条件变量
    + 条件变量常和互斥锁搭配使用
    + 某个线程改变了条件变量，将通知相应的条件变量唤醒一个或多个被此条件变量阻塞的线程
    + 互斥锁是线程间互斥的机制，条件变量则是同步机制。
  + 自旋锁
    + 如果进程/线程无法取得锁，进程/线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁。
    + 一般应用在加锁时间很短的场景。
    + 省去了睡眠唤醒的上下文切换过程。
    + 递归调用时可能产生死锁的问题
+ 守护进程、僵尸进程、孤儿进程
  + 守护进程：指在后台运行的，没有控制终端与之相连的进程。
    + 独立与控制终端，周期性的执行某种任务
  + 僵尸进程：如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程
  + 孤儿进程：如果父进程先退出，子进程还没退出，那么子进程将成为孤儿进程。
    + 孤儿进程会被init进程(进程号为1的进程)所收养

+ 局部性原理
  + 时间局部性：程序中存在大量的循环
    + 执行了某条指令，不久后该指令还会被执行
    + 访问了某个数据，不久后该数据很可能再次被访问
  + 空间局部性：很多数据以及指令在内存中都是连续存放的
    + 程序访问了某个存储单元，其附近的存储单元也很有可能被访问。
+ 死锁的处理方法
  + 鸵鸟策略
  + 死锁检测与死锁恢复
    + 资源分配图：通过检测有向图是否存在环来实现
    + 死锁恢复可以通过抢占恢复、回滚恢复、杀死进程恢复
  + 死锁预防
    + 破坏死锁的四个必要条件
      + 互斥
      + 请求和保持
      + 不可剥夺
      + 循环等待
  + 死锁避免
    + 银行家算法
+ 执行malloc申请内存时，操作系统是如何做的
  + 通常，分配的内存小于 128K 时，使用 brk 调用来获得虚拟内存，大于 128K 则使用 mmap
    + brk是将进程**数据段**(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小
    + mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。
  + 进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成