- ### 什么是进程和线程？

  \1. 进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就 是运行起来的可执行程序，进程切换时要保存cpu环境，主要有栈、寄存器、页表和新调度的进程cpu环境的设置。

  \2. 线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且 只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。多提一句： **协程**是用户态的轻量级线程，线程内部调度的基本单位。线程的切换仅需要保存和设置程序计数器、少量寄存器和栈的内容

  

  1. 线程启动速度快，轻量级
2. 线程的系统开销小
  
1. 线程使用有一定难度，需要处理数据一致性问题
  2. 同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈

  

  

  一个进程由一到多个线程组成，各线程共享进程的内存空间（代码，数据，堆）和一些进程级的资源（打开的文件和信号）。进程有自己独立的寄存器和栈。

  线程私有的是：局部变量，函数的参数，TLS（Thread Local Storage，线程局部存储）数据。

  线程之间共享（进程所有）：全局变量，堆，静态变量，程序代码，打开的文件。

  

  摘自linux内核设计与实现：

  进程是处于执行期的程序以及相关资源的总称，但不局限于可执行的代码，通常还包括其他资源，如打开的文件，挂起的信号，内核部分数据，处理器的状态，内存地址空间和线程，全局变量的数据段。

  执行线程，简称线程，是在程序中活动的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。一个进程可以含有一个或多个线程。

  在Linux中，通过调用fork()来创建进程，通过fork()复制一个现有进程来创建一个新的进程。调用fork()的称为父进程，新产生的为子进程。fork()系统调用从内核返回两次：一次回到父进程，另一次回到新生的进程。

  内核把进程的列表存放在任务队列（task list）的双向链表中。链表中的每一项都是类型为task_struct、称为进程描述符的结构。进程拥有唯一的进行标识符或PID来标识每个进程。

  Linux中所有的进程都是PID为1的init进程的后代。每个进程必有一个父进程，没有进程也拥有0个或多个子进程

  

  对于进程的创建，unix采用两个过程fork()和exec()，fork()拷贝当前进程创建一个子进程。子与父的区别仅仅在于PID，PPID和一些资源及统计量。exec()负责读取可执行文件将其载入地址空间开始运行。linux的fork()采用写时拷贝。对于fork的实现：fork调用clone函数，clone调用do_fork函数。

  linux实现线程的机制有些特别。从内核角度来讲，它并没有线程这个概念，linux把所有的线程都当作进程来实现，内核并没有准备独特的调度算法和定义数据结构来表征线程。线程仅仅被视为一个与其他进程共享资源的进程。每个线程都有唯一隶属于自己的task_struct，所以在内核中，它看起来就是一个普通的进程。而在windows中,内核提供了专门支持线程的机制，通常把这些线程称为轻量级进程。

  进程终结时，内核必须释放它所占有的资源，进程的析构是自身引起的。它发生在进程调用exit()系统调用时。
  
如果父进程在子进程之前退出，必须要有机制来保证子进程能找到一个新的进程，否则孤儿进程会处于僵死状态，解决方法是在子进程所在组内只一个进程作为父亲，如果不行，选择init作为它的父亲。；
  

  
### 线程共享的资源和特有的资源
  
- 线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。
  - 线程拥有这许多共性的同时，还拥有自己的个性，才能实现并发性

    1.线程ID

  ​    每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。

    2.寄存器组的值

  ​    由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。

    3.线程的堆栈

  ​    堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。

    4.错误返回码

  ​    由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该 线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。

    5.线程的信号屏蔽码

  ​    由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都 共享同样的信号处理器。

    6.线程的优先级

  ​    由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。

  

  ### 协程：

  一种比线程更加轻量级的存在，一个线程可以拥有多个协程。协程不是被系统内核管理，完全由程序所控制，就是在用户态下运行，这样不会像线程切换那样消耗资源

  

  ### 进程调度算法

  1. 先来先服务
2. 短作业优先
  
1. 最短剩余时间优先
  2. 时间片轮转

  1. 优先级调度
2. 多级反馈队列
  

  
### 典型的锁
  
- 读写锁
  - 互斥锁

  - 条件变量
- 自旋锁
  

  
### 线程（POSIX）锁有哪些
  
- 互斥锁
  - 条件变量

  - 自旋锁
- 信号量
  

  
### 线程回收方法
  
  - 等待线程结束：通过pthread_join。由主线程调用，等待子线程退出并回收其资源
- 结束线程：pthread_exit。子线程自己执行结束线程
  
- 分离线程： pthread_detach。主线程、子线程都可以调用。调用后和主线程分离，子线程结束后自己立即回收资源。
  
  ### 如何实现线程安全？（线程同步）

  线程安全就是内存安全，在每个进程的内存空间都会有一块特殊的公共区域，通常称为堆，进程内的所有线程都可以访问到该区域，这就是造成问题的原因。

  线程安全指的的在堆内存的数据由于可以被任何线程访问到，在没有任何限制的情况下存在被其他线程修改的风险，所以实现线程安全也就是要做到线程同步。
  
线程同步主要通过一下几种方法
  
1、synchronized锁（偏向锁，轻量级锁，重量级锁）
  
2、volatile锁，只能保证线程之间的可见性，但不能保证数据的原子性
  
3、jdk1.5并发包中提供的Atomic原子类
  
4、Lock锁
  

  

  
### 进程同步的四种方法？
  
1. 临界区：对临界资源进行访问的那段代码称为临界区。 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。
  2. 同步与互斥 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。 互斥：多个进程在同一时刻只有一个进程能进入临界区。

  1. 信号量 （Semaphore）：是一个整型变量，可以对其执行 down 和 up 操作，也就是 常见的 P 和 V 操作。
2. 管程 使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的 代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。
  
### 进程通信方式
  
1. 管道
     无名管道（内存文件）：半双工通信方式，数据只能单向流动，只能在具有亲缘关系的进程中使用
   有名管道（FIFO文件，借助文件系统）：半双工通信，允许这里没有亲缘的进程之间使用
  2. 共享内存：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。共享内存是最快的IPC方式，专门针对其他进程间通信方式低而专门设计的，往往与信号量配合使用实现进程的同步与通信

  1. 消息队列：有消息的链表，存放在内核中并由消息队列标识符标识，消息队列克服了信号传递信息少、管道只能承载无格式字符流以及缓存区大小受限等缺点。
  2. 套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式

  1. 信号：用于通知进程某个事件已经发生，比如按下ctrl + C就是信号。
  2. 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作 为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。

  

  ### Linux下同步机制？

  POSIX信号量：可用于进程同步，也可用于线程同步。

  POSIX互斥锁 + 条件变量：只能用于线程同步。

  

  ### 动态分区分配算法

  1. 首次适应
2. 最佳适应
  
1. 最坏适应
  2. 邻近适应