+ C++内存对齐

  + 内存对齐用于 struct/class/union

  + 以struct为例

    + 其中的每个元素的地址都需要是起始地址的整数倍

    + 总共大小是由最长类型决定，需要是最长类型的整数倍

      + ~~~c++
        struct Test
        {
            char c;
            double d;
            int i;
        };
        //sizeof(Test) == 24
        //char占用一个字节，double从8字节开始，因此前两个元素共占用16字节
        //int类型虽然占用4字节，但是总共大小需要是double的整数倍，因此为24
        ~~~

+ 指针和引用的区别

  + 指针是一个变量，存储的是地址，引用是原变量的别名
  + 指针可以用多级，而引用只有一级
  + 指针可以为空，引用不能为NULL且在定义时必须初始化
  + 指针在初始化之后可以改变指向，而引用在初始化后不可改变
  + sizeof指针得到的是指针类型的大小，跟机器字长有关，而sizeof引用得到的是引用对象的大小
  + 当把指针作为参数传递时，是将实参的一个拷贝副本传递给形参，两者指向的地址相同，但不是同一个变量(指针)，在函数中改变这个变量的指向不影响实参。
  + 引用本质上是一个指针，同样需要占用4字节内存
  + 引用在声明时必须初始化为另一变量，而指针的声明和定义可以分开
  + 不存在指向空值的引用，必须用具体实体；但是存在指向空值的指针。

+ 指针数组与数组指针

  + ~~~c++
    //指针数组，是一个数组，数组中的元素都是int*指针
    int* p[10];
    //数组指针，p指向这个 int[]数组。
    int (*p)[10];
    ~~~

+ 指针函数与函数指针

  + ~~~c++
    //指针函数，表示一个函数的返回值是指针，其实是一个函数声明
    int* p(int);
    //函数指针，p指向一个函数，该函数具有int类型的参数，并且返回值是int类型的
    //可以用作回调函数
    int (*p)(int)
    ~~~

+ 指针常量与常量指针

  + ~~~c++
    //指针常量，表示指针指向不可变，内容 *p 可变
    int* const p;
    //常量指针，表示指针指向可变，内容 *p 不可变
    const int* p;
    ~~~
    

+ 宏定义和typedef区别

  + 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名

  + 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分

  + 宏不检查类型；typedef会检查数据类型

  + 宏不是语句，不在最后加分号；而typedef需要

  + 注意对指针的操作

    + ~~~c++
      typedef int* t_int;
      #define d_int int*
      
      int main()
      {
          //t1 t2 都是 int*
          t_int t1,t2;
          //d1 是int* d2是int类型
          d_int d1,d2;
      }
      ~~~

+ 数组名和指针(指向数组首元素的指针)
  + 两者均可通过增减偏移量来访问数组中的元素
  + 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作
  + 当数组名当作形参传递给调用函数后，就失去了原有特性，退化成一般指针，但是sizeof运算符也不能再得到原数组的大小了。
+ 重载、重写、隐藏
  + 重载：在同一范围中有同名函数才存在重载关系。
    + 函数名相同
    + 参数类型或数目或顺序不同
      + 不能出现参数个数和类型均相同
      + 不能依靠返回值来区分
      + 虚函数、静态函数不影响重载
  + 重写：子类重写父类中的同名函数。**(基类是虚函数)**
    + 基类函数必须是虚函数
    + 参数个数相同，类型相同
    + 与基类虚函数有相同的返回值类型
      + 当返回类对象时，可以不一致，即基类返回基类类型对象，子类可以返回子类类型
  + 隐藏：子类中的函数屏蔽了基类中的同名函数
    + 两个函数参数相同，但是基类不是虚函数
    + **两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏**