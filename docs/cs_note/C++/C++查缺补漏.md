+ 调用函数时，需要将函数的参数入栈，入栈的顺序是从右到左。

+ 类的拷贝构造与复制构造。

  + 并不是有等于号 = 就是复制构造。例如在声明类对象时，直接赋值，则会调用拷贝构造

  + ~~~c++
    class A{};
    int main()
    {
        A a();
        //调用拷贝构造函数
        A a1 = a;
        A b;
        //调用复制构造函数
        b = a;
    }
    ~~~

+ C++代码需要经过编译、链接、装载运行三个过程。

  + 编译不需要完整的类实现，只要有头文件即可，编译的时候不会出错。
  + 链接的时候需要其具体实现，否则报未定义的错误。

+ 野指针与空悬指针

  + 野指针：没有被初始化的指针
  + 空悬指针：指向一块已经被释放了的内存
    + 通过使用智能指针来避免。

+ 拷贝构造函数场景

  + 用类的一个实例化对象去初始化另一个对象的时候
  + 函数的参数是类的对象时(非引用传递)
  + 函数的返回值是局部的类对象时，即返回方式是值传递时。
  
+ const对于函数重载的影响

  + 对于函数值传递的情况，因为是一个副本，所以函数内修改无法改变实参，加不加const没有影响。
  + 在引用或指针传递函数参数时，函数内部可以改变引用或指针所指向的变量内容，这时const才能够保护实参所指向的变量。
  + 编译阶段编译器对调用函数的选择是根据实参决定的，所以，只有引用传递和指针传递可以用const来重载。
    + 顶层const无法区分，只有底层const才可以实现重载。

+ 成员列表初始化

  + 当初始化一个引用成员时
  + 当初始化一个常量成员时
  + 当调用基类的构造函数，而其拥有一组参数时
  + 当调用成员类的构造函数，而其拥有一组参数时
    + 列表初始化是给数据成员分配内存空间时就进行初始化，也就是说初始化这个数据成员此时函数体还未执行。
    + 效率高的原因是，对于类型，少调用一次构造函数，而在函数体中赋值则会多一次调用。对于内置数据类型没有差别。